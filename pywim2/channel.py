# -*- coding: utf-8 -*-
"""
"""

from __future__ import division, absolute_import

import numpy as np
from numpy import matlib

import pywim2
from pywim2 import antenna

class LargeScaleParameter:
    # Delay spread and distribution
    # Angle of Departure spread and distribution
    # Angle of Arrival Spread and distribution
    # Shadow Fading standard deviation
    # Ricean K-factor

    def __init__(self):
        pass


class SupportParameter:
    # Scaling parameter for Delay distribution
    # Cross-polarisation power ratios
    # Number of clusters
    # Cluster Angle Spread of Departure
    # Cluster Angle Spread of Arrival
    # Per Cluster Shadowing
    # Auto-correlations of the LS parameters
    # Cross-corelations of the LS parameters
    # Number of rays per cluster
    pass



class CDLModel:
    pass


class Location:
    def __init__(x=0,y=0,z=0):
        x,y,x = 0,0,0


class BS:
    def __init__(self):
        pass

class MS:
    def __init__(self):
        pass

class ChannelModel:

    def __init__(self):
        self.scenario
        self.bs
        self.ms
    
    def set_scenario(self, val):
        self.scenario = val

    def set_num_BS():
        pass

    def set_num_MS():
        pass
    
    
    def _generate_coefficient(self):
        pass

    def _generate_LSP(self):
        # Assign the propagation condition, Table 4-7
        for link in links:
            link.is_los_cond = self.scenario.is_los_cond(link.Distance)
        
        # calculate the path loss, Table 4-4
        for link in links:
            link.path_loss = self.scenario
        
        # genearate the correlated large scale parameter, Section 3.2.1
        for link in links:
            pass

    def _generate_SSP(self):
        pass


class ClusterState:
    def __init__(self):        
        self.num_rays = 20
        self.ray_phases = np.zeros((self.num_rays, 2))
        self.polar_phases = np.zeros((self.num_rays,4))
        self.XPR = np.zeros((self.num_rays))
        self.theta_v = 0
        self.v = 0
        self.lambda_0 = 1
        
class ChannelState:
    def __init__(self):
        self.num_paths = 6
        self.num_rays = 20
        self.delays = None
        self.cluster_powers = None
        self.azimuth_angles = None
        self.elevation_angles = None
        self.rays_coupling = None
        self.XPR = None
        self.initial_phase = None

    def cluster(self, n):
        """
        get specified cluster state
        """
        return ClusterState()
    
class Model:
    """A WINNER phase II defined Channel Model Object
    
    Parameters
    ----------
    tx_antenna : subclass of a Antenna object.
    rx_antenna : subclass of a Antenna object.
    state : initial state of the channel model, generated by Scenario
            and NetworkLayout object.

    Examples
    --------

    See Also
    --------
    pywim2.antenna 
    """

    def __init__(self, scenario=None):
        self.tx_antenna = None
        self.rx_antenna = None
        self.scenario = scenario
        self.state = ChannelState()
        
    def filter(self, input, delay=0):
        """Filter the input signal with specified model

        Parameters
        ----------
        input : 2-dimensional array of int Shape of 
            tx antenna element x number of samples
        
        See Also 
        --------

        Notes
        -----

        Examples
        --------
        """

        coef = self.gen_coef()
        
        num_tx_ele, num_rx_ele, num_path, num_sample = coef.shape
        
        output = np.zeros((num_rx_ele, num_sample))

        delay_buffer = np.zeros((num_path, num_sample+np.max(delay)))
        for s in range(num_rx_ele):
            cluster_buffer = np.zeros((num_tx_ele, num_sample))

            for u in range(num_tx_ele):
                input_temp = matlib.repmat(input[u,:], num_path, 1)

                coef_matrix = coef[u,s,:,:]
                
                # multiple coef
                output_temp = input_temp*coef_matrix
      
                # delay
                for p in range(num_path):
                    delay_buffer[p, 
                                 delay[p]:delay[p]+num_sample] = output_temp[p, :]        

                cluster_buffer[u, :] = delay_buffer[:,:num_sample].sum(0) 

            # multipath combine
            output[s, :] = cluster_buffer.sum(0)

        return output
    
    def reset(self):
        """
        
        """
        pass

    def gen_coef(self, num_samples):
        """Generate mimo coefficient for a link

        """

        num_rx_ele = self.rx_antenna.num_elements
        num_tx_ele = self.tx_antenna.num_elements
        num_path = self.state.num_paths
        fading = np.zeros( (num_rx_ele,
                            num_tx_ele,
                            num_path,
                            num_samples) , dtype=complex)
        for s in range(num_rx_ele):
            for u in range(num_tx_ele):
                for n in range(num_path):
                    fading[s,u,n,::] = self.gen_fading(
                        self.state.cluster(n), num_samples)

        return fading
    
    def gen_fading(self, cluster_state, num_samples):
        """Generate fading coefficient for a cluster
        """
        
        ds = self.tx_antenna.uniform_distance
        du = self.rx_antenna.uniform_distance

        num_rays = cluster_state.num_rays
        
        ray_fading = np.zeros((num_rays, num_samples),dtype=complex)
        for m in range(cluster_state.num_rays):
            tx_field_pattern = np.matrix(
                self.tx_antenna.field_pattern(
                    cluster_state.ray_phases[m,0]))
            rx_field_pattern = np.matrix(
                self.rx_antenna.field_pattern(
                    cluster_state.ray_phases[m,1]))

            phi_vv, phi_vh, phi_hv, phi_hh = cluster_state.polar_phases[m,::]
            kappa = cluster_state.XPR[m]

            polar_matrix = np.matrix(
                (( np.exp(1j*phi_vv), np.sqrt(kappa)*np.exp(1j*phi_vh) ),
                 ( np.sqrt(kappa)*np.exp(1j*phi_hv), np.exp(1j*phi_hh) ))
            )

            lambda_0 = cluster_state.lambda_0
            doa, aoa = cluster_state.ray_phases[m,::]        
            v_ins = cluster_state.v*\
                    np.cos(aoa-cluster_state.theta_v) / lambda_0
            for t in range(num_samples):
                doppler_component = \
                    np.exp(1j*ds*2*np.pi*lambda_0**-1*np.sin(doa))* \
                    np.exp(1j*du*2*np.pi*lambda_0**-1*np.sin(aoa))* \
                    np.exp(1j*2*np.pi*v_ins*t)

                coef_ele = tx_field_pattern * \
                    polar_matrix * rx_field_pattern.T * doppler_component
                ray_fading[m, t] = coef_ele[0,0]

        cluster_fading = np.sum(ray_fading)

        return cluster_fading

    def gen_path_delays(self):
        pass







